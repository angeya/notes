# 算法

## 算法基础

###   时间复杂度

下面按从快到慢的顺序列出了你经常会遇到的5种大O运行时间。

 O(1)，常数时间，不一定很快，但是不管n有多大，时间都不变
 O(n)，也叫线性时间，这样的算法包括简单查找。
 O(n * log n)，如快速排序——一种速度较快的排序算法。
 O(n2)，如选择排序——一种速度较慢的排序算法。
 O(n!)，如的旅行商问题的解决方案——一种非常慢的算法。

大O表示法重点在体现量级，忽略了一般常数

### 二分查找

二分查找通过判断一目标数大于或者小于目前的数，进而缩小寻找范围。

数量级上来的时候，相对于普通遍历，查询速度快很多很多。O(n log n) 

### 数组和链表

数组需要连续内存空间，链表不需要，只需要在当前节点存放下一节点的指针

数组随机访问速度快。数组O（1），链表O（n）

链表插入和删除速度快。数组O（n），链表O（1）

散列表可以使访问、插入、删除都为O(1)，兼有二者之长

### 排序算法（升序）

1. 选择排序

   每一轮：使用第一个与后面逐一对比，如果第一个大则交换。从前面开始排

2. 冒泡排序

   每一轮：逐一用当前元素和下一个元素对比，如果第一个当前大则交换位置。从后面开始排

3. 插入排序

   假设前面的数组是有序的，然后不断从后面的数组取出一项加入有序数组，前面的数组只需将新元素插入合适的位置即可

4. 快速排序

   找一个数（一般为第一个）作为对照，比此数大的放在左边，小的的放在右边。此数放在中间。之后左右两边再进行排序

### 递归

函数自己调用自己。性能不一定高，但是容易理解，可读性高。因为递归层次很高时候，调用栈会很多，消耗大量内存。

很多时候递归的功能可以使用循环来实现。比如计算阶乘、数组求和等。

### 散列表

为了方便查找，使用散列函数和数组结合的方式，散列函数根据要查找的名称生成唯一索引（极低概率有碰撞），数组使用索引直接访问数据，查找速度为O(1)，比二分查找还要快。各大编程语言都提供了散列表的实现。如Java的hashMap，Python的字典。

为了降低碰撞的概率，可以适当扩大表长度。散列函数应该分布更加均匀。

### 广度优先搜索

广度优先搜索可以解决两类问题：

1. 从节点A出发，有前往节点B的路径吗？（在你的人际关系网中，有芒果销售商吗？/ 你从高铁站能坐公交到学校吗？）
2. 从节点A出发，前往节点B的哪条路径最短？（哪个芒果销售商与你的关系最近？/ 高铁站坐公交到学校哪一条路线最近？）

以找芒果销售商为例：

先找自己的朋友，找完了没有再找朋友的朋友。

实现方式，可以使用队列和散列表结合。

1. 首先画出关系图，然后使用散列表实现图。（如键为张三，值为他对应的朋友）
2. 将自己的朋友放入队列中，然后查找他是不是芒果销售商，如果是则搜索完成。如果不是则将他的朋友逐一放入队列中，然后访问下一个朋友。（检查一个人的时候，判断他是否已经检查过了，不判断容易造成死循环）
3. 如果队列为空了，还没有找到，那么说明你的人际关系中并没有芒果销售商。

生活中有一些事情用图画出来，会清晰和明朗很多。



### 贪心算法

思想：将一个大问题分解成小问题，每一次解决最简单（最好）的那个

优点：思路和实现都很简单

缺点：可能得出的解不是最优解，但是已经算是很不错的解了。

例如背包问题，怎样装才能使背包背的东西价值最大化。贪心算法一般不能得出最优解，最优解需要动态规划。

贪心算法可以用来解决如下问题：

1. 教室调度问题：怎样才能让教室一天中能上更多堂课。选择最早结束的课程，结束之后再从剩余的课程中选择最早结束的问题。（一般最优解）
2. 旅行商问题：如何经过每一个城市，但是最终的路程最短。选择距离当下城市最近的城市，然后再从剩余的城市中选择最近的城市。（就算不是最优解，也是很好的解法了）

### 动态规划

背包问题：如果你是一个小偷，带着一个容量为4kg的背包去商店偷东西，商店中有1kg的手机2000元，有2kg的笔记本4000元，4kg的相机5000元和4kg的显示器3000这时候你应该怎么装，才能使你背包里的东西价值最大？

使用贪心算法：找价值最大的物品往袋子中装，如果还能装得下，就选剩下的价值最大的物品，重复这个步骤。贪心算法一般能够得出较好的解，但是不是最优解。使用动态规划则可以。

动态规划解决的问题：离散的，而且大问题可以分解为小问题的解。例如：4kg容量的背包可以看做是2个1kg的背包和一个2kg的背包，1kg背包能背的最大价值是2000元（手机），2kg能背的最大价值是4000元（笔记本），这时候4kg可以装的最大价值为6000元。如果使用贪心算法，则只能装5000元（相机）

算法思路：一般需要对问题进行建模，然后使用二维数组逐一解决。后面大问题的最优解，取决于前面小问题的最优解。

最大公共子串问题：计算两个字符串中最长的公共子串长度是多少。可以使用两个字符串的字符建立起二维数组，如果某一表格中对应的行列字符相同，则值为左上角的值+1，最后取出表格中最大的数值即可得出最大公共子串长度。

### K最近邻算法(KNN)

K最近领算法可以用于分类和预测。

思路：通过确定一个目标最近相邻的K个目标的类型，从而确定该目标的类型。例如：如果你身边最亲近的10个人都是做互联网的，那么你极有可能也是做互联网的。如果和你兴趣很相似的用户最近都在看某一个电影，那么你也很有可能喜欢这个电影。由此可以做一个简单的简单推荐系统

K最近邻算法的步骤：1，提取合适的特征（分类，如对用户喜好分类）。2，对K个特征取类似的人取平均值（回归、预测，预测与这些用户喜好相关的人的喜好）。

两个人喜好的相似度可以使用毕达哥拉斯公式进行计算（通过各个指标进行计算两个人的喜好距离，如果是2个特征就是二维，如果k个特征就是K维的距离）。

面包店问题：可以根据过去不同天气、节假日、是否有活动等特征对面包销量，然后可以使用这些已知的例子，预测明天的销量--找出明天与过去最像的K种类型，进行取平均值。

## 排序算法

### 快速排序

经典、高效的排序算法。

思想：分而治之。取出数组中的第一个数，作为比较的数，比它大的数放在移动到左边，比它大的数移动到右边，它填补到最后的空位中。然后对左右两边再进行同样的操作，就能得到一个有序的数组。

稳定：不稳定。

```java
private static void quickSort(int[] array, int left, int right) {
	// 数组只有一个值，无需再排序
    if (left >= right) {
        return;
    }
    int l = left;
    int r = right;
    // 将第一个值作为比较的中间值
    int pivot = array[l];
    // 只要左右指针还没有指到一起就一直进行比较和移动操作
    while(l < r) {
        // 先从右边开始比较，如果大于比较值，就向左移动由指针
        while (l < r && pivot < array[r]) {
            r--;
        }
        // 如果右边值比比较值小，就移动到左边的空缺位（指针位）中，左指针向右移动一位
        if (l < r) {
            array[l] = array[r];
            l++;
        }
        // 从左边指针位置处开始进行比较，如果值小于比较值，就向右左移动指针
        while (l < r && pivot > array[l]) {
            l++;
        }
        // 如果左边值比比较值大，就移动到右边空缺位（指针位）中，右指针向左移动一位
        if (l < r){
            array[r] = array[l];
            r--;
        }
    }
    // 中间值填补空位
    array[l] = pivot;
    // 对左右两边递归排序
    sort(array, left, l - 1);
    sort(array, r + 1, right);
}
```

