## 高危类

### 使用空密码或者硬编码密码

**摘要**

硬编码密码、空密码可能会危及系统安全，并且无法轻易修正出现的安全问题。

**缺陷代码示例**

```java
/**
 * 默认账户密码（硬编码）
 */
String DEFAULT_PASSWORD = "Gjj@123";

/**
 * 默认账户密码（空字符串）
 */
String DEFAULT_PASSWORD = "";

/**
 * 默认账户密码（null）
 */
String DEFAULT_PASSWORD = null;
```

**缺陷描述**

- 空密码

  为密码变量指定空字符串绝非一个好方法。如果使用 empty password 成功通过其他系统的验证，那么相应帐户的安全性很可能会被减弱，原因是其接受了 empty password。如果在为变量指定一个合法的值之前，empty password 仅仅是一个占位符，那么它将给任何不熟悉代码的人造成困惑，而且还可能导致出现意外控制流路径方面的问题。null密码也一样。

  例如：使用空字符串作为密码占位符，因数据库错误或其他问题而未能取得存储的密码，攻击者只需向 userPassword 提供一个空字符串，就能轻松绕过密码检查。

- 硬编码密码

  使用硬编码方式处理密码绝非好方法。这不仅是因为所有项目开发人员都可以使用通过硬编码方式处 理的密码，而且还会使解决这一问题变得极其困难。一旦代码投入使用，除非对软件进行修补，否则 您再也不能改变密码了。如果帐户中的密码保护减弱，系统所有者将被迫在安全性和可行性之间做出选择。

  以下代码用 hardcoded password 来连接数据库：

  ```java
  DriverManager.getConnection(url, "scott", "tiger")
  ```

  该代码可以正常运行，但是任何有该代码权限的人都能得到这个密码。一旦程序发布，将无法更改数 据库用户“scott”和密码“tiger”，除非是要修补该程序。雇员可以利用手中掌握的信息访问权限 入侵系统。更糟的是，如果攻击者能够访问应用程序的字节代码，那么他们就可以利用 javap -c 命令访问已经过反汇编的代码，而在这些代码中恰恰包含着用户使用过的密码值。

**修复建议**

针对Empty Password 和 Null Password，确保始终从加密的外部资源读取存储的密码值，并为密码变量指定有意义的值。确保 始终不使用 empty password 或 null password 保护敏感资源。 

针对Hardcoded Password，绝不能对密码进行硬编码。通常情况下，应对密码加以模糊化，并在外部资源文件中 进行管理。在系统中采用明文的形式存储密码，会造成任何有充分权限的人读取和无意中误用密码。

对于加密秘钥等也是如此。



### 基于 Mybatis 的SQL注入

**摘要**

以用户或者外部不可信来源的输入动态构造SQL查询的命令，将可能改变SQL查询语句本来的语义，从 而导致执行任意的SQL命令。

**缺陷代码示例**

```xml
<select id="getItems" parameterType="java.lang.String">
 	SELECT * FROM user WHERE name = ${userName}
</select>
```

**缺陷描述**

上面的代码中，如果传入的userName参数的值为`name' OR 'a'='a'`，那么查询就会变成`SELECT * FROM user WHERE name = name' OR 'a'='a'`。附件条件` OR 'a'='a'`会使 where 从句永远评估为 true，因此该查询在逻辑上将等同于一个更为简化的查询：

```sql
SELECT * FROM user
```

**修复建议**

尽量不要在java中自己动态拼接SQL。

对于Mybatis，变量占位符请使用`#{}`，不要使用`${}`。使用 `#{}` 时，参数值会被预处理，并通过占位符的形式插入到 SQL 语句中，以避免 SQL 注入问题。

对于其他框架，也要注意动态SQL拼接的问题。



## 中危类

### 存储型绝对路径遍历

**摘要** 

允许用户输入控制文件系统操作所用的路径会导致攻击者能够访问或修改其他受保护的系统资源。 

**缺陷描述** 

当满足以下两个条件时，就会产生路径遍历错误： 

1. 攻击者可以指定某一文件系统操作中所使用的路径。
2.  攻击者可以通过指定特定资源来获取某种权限，而这种权限在一般情况下是不可能获得的。  例如，在某一程序中，攻击者可以获得特定的权限，以重写指定的文件或是在其控制的配置环境下运 行程序。

**缺陷代码示例1**

请求的输入来创建一个文件名。程序员没有考虑到攻击者可能使用像`“../../tomcat/conf/server.xml”`一样的文件名，从而导致应用程序删除它自己的配置文件。

```java
String rName = request.getParameter("reportName");
File rFile = new File("/usr/local/apfr/reports/" + rName);
...
rFile.delete();
```

**缺陷代码示例2**

下面的代码使用来自于配置文件的输入来决定打开哪个文件，并返回给用户。如果程序在一定的 权限下运行，且恶意用户能够篡改配置文件，那么他们可以通过程序读取系统中以 `.txt` 扩展名结尾的所有文件。

```java
fis = new FileInputStream(cfg.getProperty("sub")+".txt");
amt = fis.read(arr);
out.println(arr);
```

**修复建议**

 防止路径遍历的最佳方法是采用一些间接手段：例如创建一份合法资源名的列表，并且规定用户只能 选择其中的文件名。通过这种方法，用户就不能直接由自己来指定资源的名称了。  

但在某些情况下，这种方法并不可行，因为这样一份合法资源名的列表过于庞大、难以跟踪。因此， 程序员通常在这种情况下采用黑名单的办法。在输入之前，黑名单会有选择地拒绝或避免潜在的危险 字符。但是，任何这样一份黑名单都不可能是完整的，而且将随着时间的推移而过时。更好的方法是 创建一份白名单，允许其中的字符出现在资源名称中，且只接受完全由这些被认可的字符组成的输入 。

白名单的例子

```java
public boolean validateFileName(File file) throws IOException, SecurityException{
    // This represents the format d:\myapp\temp\<file name> where the file name
    // can consist of alpha-numeric, space/tab, period and dash characters and
    // cannot exceed 20 characters in length
    String goodPattern = “d:(\\\\|/)myapp(\\\\|/)temp(\\\\|/)(\\w|\\s|\\.|-){1,20}”;
    Pattern p = Pattern.compile(goodPattern, Pattern.CASE_INSENSITIVE);
    Matcher m = p.matcher(file.getCanonicalPath());
    if(!m.matches()) {
        return false;
    }
    return true;
}
```

### 密码中使用伪随机数

**摘要** 

不安全的随机数用于密码、密钥的生成。 

**缺陷描述** 

无论在何种应用程序中，密码永远是最有价值、最需要保护的资产。使用伪随机数生成密码是最糟糕 的决定，因为它一旦被猜测，整个系统就处于不设防的状态。

**缺陷代码示例**

下面Java代码片段标明不妥当的密码生成场景。 ... 

```java
...
Random random = new Random();
String password="";
for (int i=0;i<6;i++){
	password+=random.nextInt(10);
}
System.out.println(password);

```

生成6位数密码方式不当，且密码强度不足

**修复建议**

使用安全的方式生成具有足够强度和随机性的密码。



### 弱哈希

**摘要** 

弱加密散列值无法保证数据完整性，且不能在安全性关键的上下文中使用。 缺陷描述 MD2、MD4、MD5、RIPEMD-160 和 SHA-1 是常用的加密散列算法，通常用于验证消息和其他数据的完整性。然而，由于最近的密码分析研究揭 示了这些算法中存在的根本缺陷，因此它们不应该再用于安全性关键的上下文中。 

由于有效破解 MD 和 RIPEMD 散列的技术已得到广泛使用，因此不应该依赖这些算法来保证安全性。对于 SHA1，目前的破坏技术仍需要极高的计算能力，因此比较难以实现。然而，攻击者已发现了该算法的致命 弱点，破坏它的技术可能会导致更快地发起攻击。

**修复建议**

停止使用 MD2、MD4、MD5、RIPEMD-160 和 SHA-1 对安全性关键的上下文中的数据进行验证。

目前，SHA-224、SHA-256、SHA-384、SHA-512 和 SHA-3 都是不错的备选方案。但是，由于安全散列算法 (Secure Hash Algorithm) 的这些变体并没有像 SHA-1 那样得到仔细研究，因此请留意可能影响这些算法安全性的未来研究结果。



### 未检测循环条件输入

**摘要** 

攻击者可以输入一个非常高的值，可能导致拒绝服务（DOS）。

**缺陷描述**  

应用程序在循环中执行一些重复任务，并根据用户输入定义执行循环的次数。一个非常高的值可能会导致应用程序卡在循环中，无法继续其他操作。

**修复建议**： 

理想情况下，不要基于用户提供的数据建立循环。如果有必要这样做，用户输入必须首先验证， 其范围应该是有限的。



### 没有限制的文件上传

**摘要**

允许用户上传文件可能会让攻击者注入危险内容或恶意代码，并在服务器上运行。

**** 缺陷描述

 无论编写程序所用的语言是什么，最具破坏性的攻击通常都会涉及执行远程代码，攻击者借此可在程序上下文中成功执行恶意代码。如果允许攻击者向某个可通过 Web 访问的目录上传文件，并能够将这些文件传递给代码解释器（如 JSP/ASPX/PHP），他们就能促使这些文件中包含的恶意代码在服务器上执行。

即使程序将上传的文件存储在一个无法通过 Web 访问的目录中，攻击者仍然有可能通过向服务器环境引入恶意内容来发动其他攻击。如果程序容易受到路径操纵（path manipulation）、命令注入（command injection）或存在危险的文件包含（file inclusion）漏洞，那么攻击者就可能上传带恶意内容的文件，并利用另一种漏洞促使程序读取或执行该文件 。

**修复建议**： 

确保仅在文件名中使用一个扩展名。一些Web服务器，包括Apache的一些版本，可以基于内部扩 展来处理文件，以便"filename.php.gif"反馈给PHP解析器。

在一个支持不区分大小写的文件服务器运行时，确保你对提供的文件后缀执行不区分大小写的评 估。  不要仅仅依赖于文件内容的检查，以确保文件是预期的类型和大小。攻击者可能在某些文件段隐 藏代码，而这些片段仍将由服务器执行。例如，GIF图像可能包含一个自由格式的注释字段。 

 在确定如何呈现文件时，不要只依赖MIME内容类型或文件名属性。验证MIME内容类型并确保它与 扩展名匹配仅能作为解决方案的一部分。



### 隐私违规

**摘要**  

对机密信息（如客户密码或社会保障号码）处理不当会危及用户的个人隐私，这是一种非法行为。 

**缺陷描述**

隐私违规（Privacy Violation） 会在以下情况下发生： 

1. 用户私人信息进入了程序。 
2. 数据被写到了一个外部介质，例如控制台、file system 或网络。

程序员通常会信任程序 运行的操作系统，因此认为将私人信息存放在 file system、注册表或者获得局部控制的资源中是值得信任的。尽管已经限制了某些资源的访问权限，但 仍无法保证所有访问这些资源的个体都是值得信任的。

**缺陷代码示例**

以下代码包含了一个日志记录语句，该语句通过在日志文件中存储记录信息跟踪添加到数据库中 的各条记录信息。在存储的其他数值中，getPassword() 函数可以返回一个由用户提供的、与用户帐号相关的明文密码。

```java
pass = getPassword();
...
log.info(id+":"+pass+":"+type+":"+tstamp);
```

在以上示例中，代码采用日志的形式将明文密码记录到了文件系统中。虽然许多开发人员认为文件系 统是存储数据的安全位置，但这不是绝对的，特别是在涉及到隐私问题时。

**修复建议**

当安全和隐私的需要发生矛盾时，通常应优先考虑隐私的需要。为满足这一要求，同时又保证信息安 全的需要，应在退出程序前清除所有私人信息。  

为加强隐私信息的管理，应不断改进保护内部隐私的原则，并严格地加以执行。这一原则应具体说明 应用程序应该如何处理各种私人数据。在贵组织受到法律的制约时，应确保您的隐私保护原则尽量与这些法律法规保持一致。即使没有针对贵组织的相应法规，您也应当保护好客户的私人信 息，以免失去客户的信任。

保护私人数据的最好做法就是最大程度地减少私人数据的暴露。不应允许应用程序、流程处理以及员 工访问任何私人数据，除非是出于职责以内的工作需要。正如最小授权原则一样，不应该授予访问者 超出其需求的权限，对私人数据的访问权限应严格限制在尽可能小的范围内。



### 硬编码域或网址

**摘要** 

 不论在代码中，还是在配置文件、properties属性文件中，都不应出现硬编码形式的域名或网址 。 

**缺陷描述** 

 硬编码指的是在代码中将一些数字或字符串常量直接写入代码中。直接在代码中使用“魔鬼数字 ”和未经定义的字符串常量除了会降低代码的可读性，另外，如果这一个常量需要进行变更或者 修改，写“死”在代码中的常量很难去修改。  硬编码域名或网址作为其中的情形之一，其安全风险也许没有“硬编码密码”那么高，但同样属 于程序敏感数据，谨防其泄露仍是安全人员的通常做法。 

**修复建议**

首先，避免直接在源码中硬编码域名或网址，尤其不要输出到程序外部（日志等）。 其次，一定要对敏感度偏低的域名或网址硬编码的话，应当使用static final进行修饰，这样，当我们需要对其进行更改时，无论有多少个方法引用了这它，又或者这 一个值涉及到复杂的业务逻辑，只需要修改一个定义的属性即可。



### 使用浮点数进行比较

**摘要**

使用float数据进行精确计算和比较，可能由于精度问题导致程序逻辑异常。 

**缺陷描述**

使用float数据进行比较，计算机表达double和float型数据其实是个近似值，而不是精确值，直接用 它们进行比较判断，得到的结果可能与预期完全不同，导致程序逻辑异常。最严重的情况是进行相等 性比较"=="和"!="，极易错误；其次是">=""<="等比较判断，也比较容易出错。

**缺陷示例代码1**

double型数据进行判断。

```java
public static double integral(MyFunction f, double x1, double x2) {
     double x = x1;
     double result = 0;
     double step = (x2 - x1) / 700;
     while (x != x2) {
         // 可以改为 (x <= x2)
         result = result + f.valueFor(x) * step;
         x = x + step;
     }
     return result;
}

```

上述代码可能导致无限的循环，因为由于计算的误差，x!=x2，可能永远是成立的。

**缺陷示例代码2**

double型数据进行判断。

```java
public static final double MAX_MONEY=0.2；
public string test(double d1,double d2){
     double d3 = d1 + d2;
     if(d3 <= MAX_MONEY){
	     return "OK";
     }
}
```

上述代码，当d1=d2=0.1时，d3=0.20000000149011612是>0.2的，程序员想当然以为d3<=MAX_MONEY是 成立的，进行了错误的处理逻辑。

**修复建议**

1. 进行大于或等于、小于或等于，或小于某值的不同绝对值的检查，例如 Math.abs(x1 - x2) < MIN_DIFF；

   或者如：

   ```java
   boolean float_equals(float a,float b){
    if (Math.abs(a-b) <= 1e-6) {
         return true;
    }
    return false;
   }
   ```

2. 根据场景可以考虑采用整数类型或用于精确表达小数的`BigDecimal`类型替代。





## 低危类

### SQL语句查询所有结果

**摘要**

SELECT查询语句使用 * 查找所有表中所有字段。

**缺陷描述** 

通常，我们没必要将表中所有字段查询出来，增加没必要的开销。

**修复建议**

根据实际需要，查找具体字段，避免使用 * 进行遍历。

### 错误消息导致的信息泄露

**摘要**

揭示系统数据或调试信息有助于攻击者了解系统并制定攻击计划。 

**缺陷描述**

当系统数据或调试信息通过输出流或者日志功能流出程序时，就会发生信息泄漏。 

**缺陷代码示例**

以下代码会将异常打印到标准错误流： 

```java
try {
    ... 
} catch (Exception e) {
    e.printStackTrace();
}  
```

依据这一系统配置，该信息可转储到控制台，写成日志文件，或者显示给远程用户。例如，凭借脚本机制，可以轻松将输出信息从“标准错误”或“标准输出”重定向至文件或其他程序。或者，运行程 序的系统可能具有将日志发送至远程设备的远程日志记录系统，例如 "syslog" 服务器。在开发过程中，您将无法知道此信息最终可能显示的位置。  

在某些情况下，该错误消息恰好可以告诉攻击者入侵这一系统的可能性究竟有多大。例如，一个数据 库错误消息可以揭示应用程序容易受到 SQL Injection 攻击。其他的错误消息可以揭示有关该系统的更多间接线索。在上述例子中，泄露的信息可能会暗示 操作系统的类型、系统上安装了哪些应用程序，以及管理员在配置应用程序时做了哪些方面的努力。 

**修复建议**

编写错误消息时，始终要牢记安全性。在编码的过程中，尽量避免使用繁复的消息，提倡使用简短的错误消息。限制生成与存储繁复的输出数据将有助于管理员和程序员诊断问题的所在。此外，还要留意有关调试的跟踪信息，有时它可能出现在不明显的位置（例如嵌入在错误页 HTML 代码的注释行中）。

即便是并未揭示栈踪迹或数据库转储的简短错误消息，也有可能帮助攻击者发起攻击。例如，“Acces s Denied”（拒绝访问）消息可以揭示系统中存在一个文件或用户。



### 日志伪造

**摘要**

将未经验证的用户输入写入日志文件可致使攻击者伪造日志条目或将恶意信息内容注入日志。 

**缺陷描述**

在以下情况下会发生 Log Forging 的漏洞： 

	1.  数据从一个不可信赖的数据源进入应用程序。 
	1.  数据写入到应用程序或系统日志文件中。  

为了便于以后的审阅、统计数据收集或调试，应用程序通常使用日志文件来储存事件或事务的历史记 录。根据应用程序自身的特性，审阅日志文件可在必要时手动执行，也可以自动执行，即利用工具自 动挑选日志中的重要事件或带有某种倾向性的信息。

如果攻击者可以向随后会被逐字记录到日志文件的应用程序提供数据，则可能会妨碍或误导日志文件 的解读。最理想的情况是，攻击者可能通过向应用程序提供包括适当字符的输入，在日志文件中插入 错误的条目。如果日志文件是自动处理的，那么攻击者就可以通过破坏文件格式或注入意外的字符， 从而使文件无法使用。更阴险的攻击可能会导致日志文件中的统计信息发生偏差。通过伪造或其他方 式，受到破坏的日志文件可用于掩护攻击者的跟踪轨迹，甚至还可以牵连第三方来执行恶意行为

**缺陷代码示例**

应用程序代码会尝试从一个请求对象中读取整数值。如果数值未被解析为整数，输入就会被记录到日 志中，附带一条提示相关情况的错误消息。

```java
...
String val = request.getParameter("val");
try {
	int value = Integer.parseInt(val);
}catch (NumberFormatException nfe) {
	log.info("Failed to parse val = " + val);
}
```

如果用户为`“val”`提交字符串`“twenty-one”`，则日志中会记录以下条目：

```
 INFO: Failed to parse val=twenty-one
```

然而，如果攻击者提交字符串`“twentyone%0a%0aINFO:+User+logged+out%3dbadguy”`，则日志中会记录以下条目： 

```
INFO: Failed to parse val=twenty-one INFO: User logged out=badguy 
```

显然，攻击者可以使用同样的机制插入任意日志条目。

**修复建议**

打印日志之前或者在程序接收用户之前，对用户输入做一些校验。或者选择不可进行日志注入的日志框架。



### 服务端请求伪造

**摘要** 

web应用服务端提供了从其他服务器应用获取数据的功能，但没有对目标地址做过滤与限制。攻击者可 能滥用此漏洞：扫描内部服务；对受保护的网络发起代理攻击；绕过网络控制；下载未经授权的文件 ；访问内部服务和管理界面；并可能控制请求的内容，甚至窃取服务器凭据。 

**缺陷描述**

应用程序接受来自用户的 URL（或其他数据），并用它向另一个远程服务器发出请求。 

但是，攻击者可以在请求中注入任意 URL，导致应用程序连接到攻击者想要的任何服务器。这样，攻击者可能滥用应用程序来访问本不可访 问的服务，并伪装请求来自应用程序服务器。 

一般情况下，SSRF（Server-side Request Scripting，服务端请求伪造）攻击的目标是从外网无法访问的内部系统。正是因为它是由服务端发 起的，所以它能够请求到与它相连而与外网隔离的内部系统。因此，包含SSRF漏洞的web应用同时是受 害者和协助恶意攻击的从犯（跳板）。攻击者正是通过篡改获取资源的请求发送给包含SSRF漏洞的服 务器，但是服务器并没有发现在这个请求的合法性，然后服务器以它自身的身份来访问其他服务器的 资源。

**修复建议**

1. 过滤内网服务器对公网服务器请求的响应。如果Web应用是获取某一类型的文件，在把返回结果展示给 用户之前应先验证返回的信息是否符合文件类型标准，比如返回信息应为图片，如果返回信息是HTML ，则停止将返回信息返回客户端。 
2.  统一错误提示信息，避免用户可以根据错误信息来判断远端服务器的端口状态。
3. 在内网服务器的防火墙上限制公网服务器的请求端口为HTTP等协议常用端口，如：80、443、8080、8 090。
4. 若公网服务器的内网IP与内网无业务通信，建议将公网服务器对应的内网IP列入黑名单，避免应用被用来获取内网数据。 
5. 内网服务器禁用不必要的协议，仅允许HTTP和HTTPS请求，防止类似于file:///、gopher://、ftp: // 等协议引起的安全问题。