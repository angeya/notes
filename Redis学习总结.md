# Redis总结

## 1、简介与安装

### 1.1简介

Redis基于C语言开发、代码量3万多行。是一个开源、高性能的、基于键值对的缓存与存储系统，通过提供多种键值数据类型来适应不同应用场景下的缓存和存储需求。同时Redis的诸多高级功能使其可以胜任消息队列、任务队列等不同角色。

Redis 是单线程模型（这里的单线程指的是 IO 和键值对的读写是一个线程完成的），当然如果严谨的来说还是可以理解为是多线程，不过多线程不过是在数据备份的时候会 fork 一个子进程对数据进行从磁盘读取数据并组装 RDB，然后同步给 slaver 节点的操作，当然包括备份和持久化也都是通过另外起线程完成的。我们可以把 Redis 认作为一个单线程模型。

1. 数据类型

   Redis支持的键值数据类型如下：

   - 字符串类型

   - 散列类型

   - 列表类型

   - 集合类型

   - 有序集合类型

2. 基于内存

   Redis数据库中的数据都存储在内存中。因此在性能上相对于其他基于硬盘存储的数据库有明显的优势。Redis在普通的笔记本电脑可以在一秒内读写超过10万个键值。

   Redis还提供数据数据持久化的支持，将内存中的数据异步写入到硬盘中，同时正常提供服务。

3. 功能丰富

   Redis虽然作为数据库开发的，但是提供了丰富的功能，可以用来做缓存、消息队列、发布/订阅系统等。

4. 简单

   Redis直观的存储结构使得通过程序与Redis交互十分简单。Redis提供了100多个数据操作的命令，但是常用的只有十几个。

### 1.2安装

在官网下载压缩包（默认没有windows版的），上传到linux某路径进行解压，然后执行 make 和 make install 命令进行编译。之后执行 ./redis-server即可启动服务端，如果想使用配置文件则在命令后面接上配置文件路径即可。通过./redis-cli启动客户端。

启动服务：

```bash
redis-server redis.conf # 不指定配置文件，则使用默认配置。关闭服务可以使用客户端的 shutdown 命令来实现
```

启动客户端：

```bash
redis-cli -h 127.0.0.1 -p 6379 -a password # 如果没有启动参数，则使用默认值
```



### 1.3 常见配置：

```properties
# 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0
bind 0.0.0.0
# 守护进程，修改为yes后即可后台运行
daemonize yes 
# 密码，设置后访问Redis必须输入密码
requirepass 123321
# 监听的端口
port 6379
# 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录
dir .
# 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15
databases 1
# 设置redis能够使用的最大内存
maxmemory 512mb
# 日志文件，默认为空，不记录日志，可以指定日志文件名
logfile "redis.log"
# 是否使用aof的持久化方式
appendonly no
```



## 2、入门

### 2.1基础

推荐key的命名规则：

多个单次之间使用点号分割。

基础命令如下：

| 命令         | 说明                                          | 示例   |
| ------------ | --------------------------------------------- | ------ |
| keys pattern | 获取符合规则的键名列表，pattern支持glob通配符 | keys * |
| del key      | 删除键值对                                    |        |
| type key     | 查看键值数据类型                              |        |

### 2.2字符串类型

应用场景：存储字符串和数字，如对象、数量等。

| 命令                                  | 说明                                                   | 示例               |
| ------------------------------------- | ------------------------------------------------------ | ------------------ |
| set key value                         | 创建键值对                                             | set name zhangsan  |
| get key                               | 取值                                                   | get name           |
| setnx key value                       | 如果键不在则创建（可结合del命令实现分布式锁）          |                    |
| del key                               | 删除键值对                                             |                    |
| incr key                              | 键对应的值递增                                         | incr age           |
| incrby key n                          | 键对应的值加上数值n                                    | incrby age 2       |
| decr key                              | 与incr类似、递减                                       |                    |
| decrby key n                          | 键对应的值减去数值f                                    |                    |
| incrbyfloat key f                     | 增加浮点数f                                            |                    |
| append key value                      | 向尾部追加内容                                         | append name lisi   |
| strlen key                            | 获取键值字符串长度                                     |                    |
| mget key [key...]                     | 获取多个键值                                           |                    |
| mset key value [key value ...]        | 设置多个键值                                           |                    |
| getbit key offset                     | 获取字符串对应二进制位的值（0/1），一个字符8位         |                    |
| setbit key offset value               | 设置字符串对应位的值                                   |                    |
| bitcount key [start] [end]            | 获取字符串中值是1的二进制位个数                        |                    |
| bitop operation destkey key [key ...] | bitop支持的运算操作有and、or、xor、not等用于进行位运算 | bitop or key1 key2 |

### 2.3散列类型（Hash -> h开头）

一个散列类型中可以包含多个字段。

| 命令                                | 说明                               | 示例                   |
| ----------------------------------- | ---------------------------------- | ---------------------- |
| hset key field value                | 设置一个map键值                    | hset car name BWM      |
| hget key filed                      | 获取一个map的键值                  | hget car name          |
| hmset key field value [field value] | 设置map的多个键值                  |                        |
| hmget key filed [field...]          | 获取map的多个键值                  |                        |
| hgetall key                         | 获取map所有的键值对                |                        |
| hsetnx key field value              | 字段不存在则赋值，存在不做任何操作 |                        |
| hexists key field                   | 判断mao中的键（字段）是否存在      | hexists car name       |
| hincrby key field                   | map中某个字段的值增加              | hincrby car price 2000 |
| hdel key field [field...]           | 删除map中的多个字段                |                        |
| hkeys key                           | 获取map中的所有字段                |                        |
| hvalues key                         | 获取map中个所有值                  |                        |



### 2.4列表类型（List -> l开头）

列表类型是一个双向链表。可以通过两端的操作实现栈和队列。新增快，遍历慢。

| 命令                                  | 说明                                                         | 示例                               |
| ------------------------------------- | ------------------------------------------------------------ | ---------------------------------- |
| lpush key value [value...]            | 从列表左边插入元素                                           |                                    |
| rpush key value [value...]            | 从列表右边插入元素                                           |                                    |
| lpop key                              | 从列表左边弹出元素                                           |                                    |
| rpop key                              | 从列表右边弹出元素                                           |                                    |
| llen key                              | 获取列表元素格式                                             |                                    |
| lrange key start end                  | 获取列表的片段，负数从右边开始计数，超出列表范围则返回有重叠的部分 |                                    |
| lrem key count value                  | 删除count个值为value的元素，count<0行右边开始删，count为0删除所有 |                                    |
| lindex key index                      | 通过索引获取元素，类似数组                                   |                                    |
| lset key index value                  | 通过索引设置元素值，类似数组                                 |                                    |
| ltrim key start end                   | 只保留列表的指定片段，如只保留前100条日志                    | ltrim logs 0 99                    |
| linsert key before\|after pivot value | 向列表中插入元素                                             | linsert name.list after 7 zhangsan |
| rpoplpush source destination          | 将元素从一个列表弹出，插入到到另一个列表，source和destination相同可以达到循环的效果 |                                    |

### 2.5集合类型（Set -> s开头）

集合类型元素是无序的，内部通过散列表实现，增删等操作的复杂度是O(1)。还可以进行集合间的并、交、差集的运算。

| 命令                       | 说明                                                         | 示例               |
| -------------------------- | ------------------------------------------------------------ | ------------------ |
| sadd key member[member...] | 向集合中加入元素                                             |                    |
| srem key member[member...] | 从集合中删除元素                                             |                    |
| smembers key               | 获取集合中的所有元素                                         |                    |
| sismember key member       | 判断元素是否在集合中                                         |                    |
| sdiff key [key...]         | 计算多个集合的差集，顺序进行                                 |                    |
| sinter key [key...]        | 计算多个集合的交集                                           |                    |
| sunion key [key...]        | 计算多个集合的并集                                           |                    |
| scard                      | 获取集合元素个数                                             |                    |
| srandmember key [count]    | 随机获取集合元素，count指定个数，默认为1，count大于0不重复，count小于0可能重复（因为基于hashtable，桶是随机的，但是元素不一定能够随机） | srandmember set 20 |
| spop key                   | 弹出一个元素（因为无序，所以是随机的）                       |                    |



### 2.6有序集合类型（z开头）

有序集合是使用散列表和跳跃表实现的，所以读取中间元素的速度也很快（O(log(N))）,有序集合比列表更消耗内存。

有序列表通过给定的分数来排序的，分数小的排序在前面。

| 命令                                                       | 说明                                                         | 示例                          |
| ---------------------------------------------------------- | ------------------------------------------------------------ | ----------------------------- |
| zadd key score member [score member...]                    | 向集合中加入元素                                             |                               |
| zscore key member                                          | 获取元素的分数                                               |                               |
| zrange key start stop [withscore]                          | 获取排名在某个范围的元素列表，加入withscore参数表示返回元素的分数 | zscore scores shangsan        |
| zrevrange key start stop [withscore]                       | 与zrange相反顺序                                             |                               |
| zrangebyscore key min max [withscore] [limit offset count] | 获取分数在min和max之间的元素，min和max可以在左边加上"("表示不包含端点，也可使用-inf和+inf表示正负无穷，limit与mysql类似，可以实现分页 | zrangebyscore scores (80 +inf |
| zincr key score member                                     | 增加某个元素的分数，score为负数表示减                        |                               |
| zcard key                                                  | 获取集合中元素数量                                           |                               |
| zcount key min max                                         | 获取分数在min和max范围内的元素个数                           |                               |
| zrem key member [member...]                                | 删除一个或多个元素                                           |                               |
| zremrangebyrank key  start end                             | 按照排名范围删除元素                                         |                               |
| zremrangebyscore key  start end                            | 按照分数范围删除元素                                         |                               |
| zinterstore / zunionstore                                  | 计算有序集合的交集并集                                       |                               |



## 2.7新数据类型

#### 2.7.1 Bitmaps

Bitmaps其实是字符串类型，不过可以实现对二进制位的处理，并提供一套不同于字符串的命令。

可以把Bitmaps想象成一个以位为单位的数组，数组的每个单元只能存储0和1，数组的下标在Bitmaps中叫做偏移量。Bitmaps之间可以做交集并集等操作。

使用场景：存储网站用户登录情况，使用集合存储用户id会占用过多内存。这时候可以使用Bitmaps的偏移量当做用户id，位的值为1来表示登录。如果总用户量很多但是登录人数很少的情况也不太合适使用Bitmaps。

#### 2.7.2 HyperLogLog

HyperLogLog是用来做基数(数据集中不重复的元素)统计的算法。相对于使用set是节省统计内存空间。

#### 2.7.3 Geospatial

用于存储经纬度信息，并且可以计算不同坐标点计算出距离等。



## 3、进阶

### 3.1事务

1. multi和exec命令

   事务的实现可以使用multi命令和exec命令。

   Redis收到multi命令之后，会将之后接收到的其他命令缓存起来，直到遇到exec命令才会将缓存的命令逐一执行。最后统一返回每一条命令的执行结果。也可以通过discard命令放弃事务。

   如果事务缓存过程中有命令语法错误，则事务的所有命令都不会执行。

   如果事务执行过程中有命令发生了错误，Redis没有提供回滚功能，会继续往下执行其他命令。不过一般只要在开发的时候注意测试，一般不会出现命令报错的问题。

2. watch命令（用于乐观锁，redis默认无法直接使用悲观锁）

   watch命名可以用来监控若干个键，可以通过unwatch或者exec命令取消监控。监控时如果这些键值在exec命令之前发生了改变（数据版本号改变），事务exec命令将不会执行，直接返回空结果。

   在秒杀系统中，使用watch实现乐观锁会带来库存遗留问题。因为多个并发操作时，很多用户会因为watch版本号被修改而放弃执行事务秒杀。

3. Redis事务的3大特性

   - 单独的隔离操作

     事务中命令会被顺序地执行，执行过程中不会被其他客户端发送过来的命令打断。

   - 没有隔离级别的概念 

     不像MySql等可以多个事务同时进行，所以没有隔离级别的概念。

   - 不保证原子性

     事务中如果有命令失败，其他命令依旧会执行。不保证都失败或者都成功。

4. 使用lua脚本可以实现多个命令作为一个命令来使用，可以实现原子操作，保证并发安全。

### 3.2过期时间

验证码、优惠活动、缓存等一般是需要设置有效时间的，过期则删除。可以通过expire命令设置，有效时间单位为秒（pexpire命令可以精确到毫秒）。如expire session 90。

如果想知道一个键还有多久过期，则可以使用ttl（Time to life）命令，如 ttl session

如果键不存在，ttl返回-2，如果键没有设置过期时间，ttl返回-1

使用persist命令可以清除过期时间，如persist session。set和getset命令也会清除过期时间。

### 3.3排序

除了使用有序集合外，Redis还提供了sort命令来对列表类型、集合类型、和有序集合类型进行排序，并且可以完成与关系数据库中的连接查询相类似的任务。

rort命令：

命令格式 sort list ，后面接desc参数进行倒序排序，默认是asc。sort命令会尝试将元素转为双精度浮点数来比较，如果无法转换则会提示错误。可以接alpha参数进行字典序排序。

sort命令还可以通过by、get参数进行更加精细的排序控制。

### 3.4消息通知

1. 消息队列

   列表数据类型可以用来实现队列。生产者不断将元素加入队列、消费者不断从队列取出元素。

   使用brpop弹出命令可以使队列为空时阻塞，直到可以从队列中取到元素。

   命令格式：brpop list[, timeout ] ，timeout是超时时间，与java中的BlockingQueue类似

2. 优先级队列

   有时候任务的紧急程度不同。紧急的任务需要优先处理。

   brpop可以消费多个队列，只要前面的队列有元素，则优先取前面队列的元素。

   命令格式：brpop list1: timeout1 list2: timeout2 ...

3. 发布/订阅模式

   发布/订阅模式中包含两种角色，发布者和订阅者。订阅者可以订阅一个或若干个频道，发布者可以向指定的频道发送消息，所有订阅了此频道的订阅者都可以收到消息。

   订阅消息：subscribe channel，订阅消息之后进入订阅状态，只能使用subscribe、unsunscribe、psubscribe（按照规则订阅频道）和punsubsrcibe（退订指定的规则）命令。

   发布消息：publish channel hello


### 3.5管道

当执行多条类似命令时，网络开销会比较大。使用管道技术可以实现多条命令一次发送，结果打包一次返回的效果。

每一种编程语言都有各自实现管道的方法。

## 4、持久化

Redis是将数据保存在内存中的，然而内存中的数据在Redis重启之后就会丢失。

因此，Redis支持两种方式的持久化，一种是RDB，一种是AOF。AOF方式的数据损失比RDB方式更小，但是性能损失较大。用哪一种方式都可以，不过一般两种方式一起使用。

在Redis重启的时候，会加载持久化文件恢复数据。当RDB和AOF方式都打开时，Redis 优先使用AOF的方式恢复数据，为它的数据更加完整。

当Redis持久化文件损坏时，可以通过 `redis-check-aof` 和 `redis-check-rdb` 命令进行手动修复。

### 4.1RDB方式（Redis DtaBase）

RDB持久化方式是通过快照完成的，当符合一定条件时Redis会自动将内存中的所有数据生成一份副本保存在硬盘上，这个过程称为“快照”。Redis会在以下几种情况对数据进行快照。

1. 根据配置规则进行自动快照

   Redis允许用户在配置文件中自定快照条件，由两个参数构成：时间窗口M和改动的键的个数N。每当时间M内被更改的键个数大于等于N时，即符合自动快照条件。如

   save 900 1 # 15分钟更新1条及以上

   save 300 10 # 5分钟更新10一条及以上

   save 60 1000 # 1分钟更新1000条及以上

   配置的条件之间是或的关系，满足任意一条都会自动快照。

2. 用户执行save或bgsave命令

   - save命令

     可以通过执行save命令进行快照，但是快照执行过程中会阻塞所有客户端请求。所以一般不会再生产环境使用。

   - bgsave命令

     与save类似，只是采用的是异步快照的策略。可以通过lastsave命令获取上一次快照时间来判断快照是否成功。

3. 执行flushall命令

   flushall命令会清空数据库中的所有数据。只要自动快照条件不为空就会触发快照，如果自动快照条件为空flushall命令则不会进行快照。

4. 执行复制时

   设置了主从模式时，Redis会在复制初始化时进行自动快照。

快照原理：

Redis默认会将快照文件存储在当前进程工作目录的dump.rdb文件（可通过dir和dbfilename配置）中。快照的过程如下：

1. Redis使用fork函数复制一份当前进程（父进程）的副本（子进程）
2. 父进程继续接收并处理客户端请求，而子进程开始将内存中的数据写入临时文件（使用写时复制策略，保证不会使用双倍内存）
3. 当子进程写完所有数据后会用该临时文件替换旧的RDB文件，至此一次快照操作完成。

### 4.2AOF方式（Append Only File）

AOF可以将Redis执行的每一条写命令追加到硬盘文件中，这一过程显然会降低Redis性能，不过大部分这个影响可以接受，也可以通过提高硬盘速度提高性能。

默认情况下Redis没有开启AOF方式的持久化，可以通过配置 appendonly yes 启用。AOF文件的保存位置和RDB文件相同（可通过dir和appendfilename配置，默认文件名为appendonly.aof）。

每当aof文件达到一定大小时，将会将会进行优化重写，避免文件过大。

优化主要内容为：去除那些被覆盖了的无用命令，如set age 23,set age 24，那么前面的set命令其实被后面的命令覆盖了。

### 4.3同步硬盘数据

虽然每次执行更新数据库操作时，AOF都会将命令记录在aof文件中，但是由于操作系统的缓存机制，数据并没有真正写入硬盘，而是进入了系统的硬盘缓存，默认情况下系统30s才会执行一次同步操作将硬盘缓存中的内容真正地写入硬盘，这异常情况下可能会出现30s的数据丢失。

这就需要Redis在写入aof文件后主动要求系统将缓存内容同步到硬盘中。通过appendfsync配置：

appendfsync always # 每条命令一次，性能损耗

appendfsync everysec # 每秒一次，默认值，推荐值

appendfsync # no，跟随系统，30秒一次，容易丢失数据

## 5、集群

### 5.1主从复制

通过持久化功能，Redis保证了在服务器重启的情况下也不会损失数据（或少量损失），但是如果服务器损坏，数据就没有了。使用主从架构有以下优点：

数据冗余：实现数据的热备份，是持久化的一种冗余方式

故障恢复：当主节点出现问题，可以由从节点提供服务，实现快速的故障恢复，服务冗余

负载均衡：分担服务负载，大大提高redis的并发量

高可用基石：主从复制还是哨兵和集群能够实施的基础

1. 配置

   主从架构可以一个主数据库配多个从数据库。Redis的主从架构非常容易，主数据库无需配置，只需在从数据库中使用slave命令配置主库即可。

   如 slaveof 127.0.0.1 6379 将自己设置为127.0.0.1 6379库的从数据库。

   在配置文件中配置可以永久生效，配置格式如下：

   replicaof ip port

   可以通过info命令查看各个Redis实例的角色。

2. 原理

   当一个从数据库启动后，会主动向主数据库发送psync命令。主数据库收到sync命令后会开始在后台保存快照（RDB持久化），并将快保存照期间接收到的命令保存缓存起来，然后将快照文件和缓存的命令发送给从数据库。

   当主从数据库连接断开并重新连接后，主数据库会将断连期间接收到的写命令发送给从数据库进行增量复制（如果不满足增量复制条件则进行全量复制）。

3. 读写分离

   主从数据库通过读写分离可以提高服务器的负载能力。一般主数据库只进行写操作、从书库只负责读操作。

### 5.2哨兵

在主从架构中，一般将比较耗时的持久化操作让从数据库来做，主数据库禁用持久化。如果从数据库崩溃重启之后主数据库自动会将数据同步过来。如果主数据库崩溃，则需要手动在从数据库中使用slaveof no one命令升级为主数据库继续服务。重启之前崩溃的主数据库，然后使用slaveof命令将其设置为新主库的从库，即可将数据同步回来。

以上手工步骤比较繁琐，Redis提供了哨兵工具来实现自动化的系统监控和故障恢复功能。哨兵（独立运行的进程）主要包括以下两个功能：

- 监控所有数据库（以及其他哨兵，如果有）是否正常运行。
- 主数据库出现故障时自动将从数据库转化为主数据库。

哨兵的配置与启动

```bash
#sentinel.conf  哨兵配置文件  后面的1 表示主机挂了，投票看谁接替成为主机
sentinel monitor 主数据库名称 127.0.0.1 6379 1
#启动哨兵
redis-sentinel sentinel.conf
```

每个哨兵会自动获取从节点的信息，如果主机宕机，所有哨兵继续拧投票选出带头哨兵，然后带头哨兵负责选出新的主数据库，同时尝试恢复之前的主数据库，如果恢复了，只能变为从数据库。

### 5.3集群

主从复制只是单个数据库的复制，不是扩展。当单个数据库不能满足业务需求时，就需要建立集群提供服务。

哨兵和集群是两个独立的功能，但是从特性来看哨兵可以视为集群的子集，当不需要数据分片的场景下哨兵就足够了，如果需要进行水平扩容，集群是一个不错的选择。

使用集群只需要每个数据库节点的cluster-enable配置选项打开即可。且每个集群需要至少3个主数据库才能正常运行。

## 6、管理

### 6.1安全

可以为Redis配置密码，以及绑定ip等。

### 6.2管理工具

使用RedisInsight工具可以对Redis进行可视化管理。

### 6.3常用配置

